<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MiniCraft+ ‚Äî Performance Build</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#111;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  #ui{position:fixed;inset:0;pointer-events:none}
  #hint{position:absolute;left:50%;top:10px;transform:translateX(-50%);background:rgba(0,0,0,.55);padding:6px 10px;border-radius:10px;font-weight:800;display:none;border:2px solid #000}
  #hotbar{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);display:flex;gap:6px}
  .slot{pointer-events:auto;width:44px;height:44px;border:2px solid #000;border-radius:8px;background:rgba(0,0,0,.35);display:grid;place-items:center;box-shadow:0 4px 16px rgba(0,0,0,.4)}
  .slot.active{outline:2px solid #4fc3ff}
  .blk{width:24px;height:24px;border-radius:4px;box-shadow:inset 0 2px 0 rgba(255,255,255,.2)}
  .grass{background:linear-gradient(#6bc760,#4c8f44)}
  .dirt{background:linear-gradient(#8b5a3c,#5c3b26)}
  .stone{background:linear-gradient(#bfbfbf,#8e8e8e)}
  .sand{background:linear-gradient(#f0e3a1,#d1c27e)}
  .wood{background:linear-gradient(#b0763d,#7a4f25)}
  .leaves{background:linear-gradient(#7fe37a,#4aa34f)}
  .water{background:linear-gradient(#5bc0ff,#2c7df0)}
  .glass{background:linear-gradient(#d3ecff,#96c8ff)}
  #cross{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:22px;height:22px;opacity:.85}
  #cross:before,#cross:after{content:"";position:absolute;background:#fff}
  #cross:before{left:50%;top:0;width:2px;height:100%;transform:translateX(-50%)}
  #cross:after{top:50%;left:0;width:100%;height:2px;transform:translateY(-50%)}
  #overlay{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.6)}
  .card{background:#1a1f2a;border:2px solid #000;border-radius:14px;padding:16px;text-align:center;max-width:680px}
  .btn{display:inline-block;margin-top:10px;background:#2c7df0;color:#fff;padding:10px 14px;border-radius:10px;font-weight:900;text-decoration:none;pointer-events:auto}
  #perf{position:fixed;left:10px;top:10px;background:rgba(0,0,0,.5);border:2px solid #000;border-radius:10px;padding:8px;display:flex;gap:8px;align-items:center;pointer-events:auto}
  #fps{font-weight:900}
</style>
<script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
</head>
<body>
  <div id="overlay">
    <div class="card">
      <h2>MiniCraft+ ‚Äî Performance</h2>
      <p>Optimerad build med justerbart <b>Render Distance</b> och <b>Performance mode</b> f√∂r svagare datorer.</p>
      <a href="#" class="btn" id="start">‚ñ∂Ô∏è Starta</a>
    </div>
  </div>

  <div id="perf">
    <label>Render Distance:
      <select id="rd">
        <option value="1">Low (1)</option>
        <option value="2" selected>Medium (2)</option>
        <option value="3">High (3)</option>
      </select>
    </label>
    <label><input id="pMode" type="checkbox" checked/> Performance mode</label>
    <span id="fps">FPS: --</span>
  </div>

  <div id="ui">
    <div id="hint">üîí Klicka f√∂r att l√•sa musen</div>
    <div id="hotbar"></div>
    <div id="cross"></div>
  </div>

<script>
// ===== Basics & helpers =====
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function makeNoise(seed=1337){
  let x=seed|0; function rnd(){ x^=x<<13; x^=x>>17; x^=x<<5; x|=0; return (x>>>0)/4294967295; }
  const p=new Uint8Array(512); for(let i=0;i<256;i++) p[i]=i; for(let i=255;i>0;i--){ const j=(rnd()*256)|0; const t=p[i]; p[i]=p[j]; p[j]=t; } for(let i=0;i<256;i++) p[256+i]=p[i];
  const grad=[[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]; const F=0.366025403,G=0.211324865; function dot(g,x,y){return g[0]*x+g[1]*y;}
  return function n2(xin,yin){
    let n0=0,n1=0,n2=0; const s=(xin+yin)*F; const i=Math.floor(xin+s), j=Math.floor(yin+s);
    const t=(i+j)*G, X0=i-t, Y0=j-t; const x0=xin-X0, y0=yin-Y0; let i1,j1; if(x0>y0){i1=1;j1=0;} else {i1=0;j1=1;}
    const x1=x0-i1+G, y1=y0-j1+G, x2=x0-1+2*G, y2=y0-1+2*G; const ii=i&255, jj=j&255;
    const gi0=grad[p[ii+p[jj]]%8], gi1=grad[p[ii+i1+p[jj+j1]]%8], gi2=grad[p[ii+1+p[jj+1]]%8];
    let t0=0.5 - x0*x0 - y0*y0; if(t0>0){ t0*=t0; n0=t0*t0*dot(gi0,x0,y0); }
    let t1=0.5 - x1*x1 - y1*y1; if(t1>0){ t1*=t1; n1=t1*t1*dot(gi1,x1,y1); }
    let t2=0.5 - x2*x2 - y2*y2; if(t2>0){ t2*=t2; n2=t2*t2*dot(gi2,x2,y2); }
    return 70*(n0+n1+n2);
  }
}
const noise = makeNoise(42), noise2 = makeNoise(1337);

// ===== Settings (tweakable) =====
const CHUNK=16, HEIGHT=88, SEA=18;
let RADIUS = 2; // default medium
let PERF_MODE = true; // reduces transparency & day/night math

// ===== World constants =====
const BLOCK={ Air:0, Grass:1, Dirt:2, Stone:3, Sand:4, Wood:5, Leaves:6, Water:7, Glass:8, Coal:9, Iron:10 };
const BLOCK_LIST=[BLOCK.Grass,BLOCK.Dirt,BLOCK.Stone,BLOCK.Sand,BLOCK.Wood,BLOCK.Leaves,BLOCK.Water,BLOCK.Glass];
const COLORS={
  [BLOCK.Grass]:0x6bc760, [BLOCK.Dirt]:0x7a4f25, [BLOCK.Stone]:0x9a9a9a, [BLOCK.Sand]:0xefe2a0,
  [BLOCK.Wood]:0xb0763d, [BLOCK.Leaves]:0x59c45a, [BLOCK.Water]:0x2c7df0, [BLOCK.Glass]:0xd3ecff,
  [BLOCK.Coal]:0x444444, [BLOCK.Iron]:0xd8c6b1
};
const TRANSPARENT={ [BLOCK.Water]:0.6, [BLOCK.Glass]:0.2 };

// ===== UI: hotbar & perf =====
const hotbar=document.getElementById('hotbar'); let selected=0;
function buildHotbar(){
  hotbar.innerHTML='';
  const cls=['','grass','dirt','stone','sand','wood','leaves','water','glass'];
  BLOCK_LIST.forEach((b,i)=>{
    const d=document.createElement('div'); d.className='slot'+(i===selected?' active':'');
    const c=document.createElement('div'); c.className='blk '+cls[b]; d.appendChild(c);
    d.onclick=()=>{ selected=i; buildHotbar(); }; hotbar.appendChild(d);
  });
} buildHotbar();
addEventListener('keydown', e=>{ if(e.key>='1'&&e.key<='8'){ selected=(+e.key-1); buildHotbar(); } });

const rdSel=document.getElementById('rd'); rdSel.onchange=()=>{ RADIUS=+rdSel.value; rebuildAround(true); };
const pMode=document.getElementById('pMode'); pMode.onchange=()=>{ PERF_MODE=pMode.checked; renderer.shadowMap.enabled=false; };

const fpsEl=document.getElementById('fps'); let frames=0, lastFps=performance.now();
setInterval(()=>{ const now=performance.now(); const fps=(frames*1000)/(now-lastFps); fpsEl.textContent='FPS: '+Math.round(fps); frames=0; lastFps=now; }, 1000);

// ===== Three.js Scene =====
const scene=new THREE.Scene(); scene.background=new THREE.Color(0x87b6ff);
const camera=new THREE.PerspectiveCamera(75, innerWidth/innerHeight, .1, 2000);
const renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth,innerHeight); document.body.appendChild(renderer.domElement);
addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

const sun=new THREE.DirectionalLight(0xffffff, 0.9); sun.position.set(1,1,.5); scene.add(sun); scene.add(new THREE.AmbientLight(0x404040));

// ===== Pointer lock (custom + auto re-lock) =====
const overlay=document.getElementById('overlay'), hint=document.getElementById('hint');
function setHint(v){ hint.style.display = v ? 'block' : 'none'; }
function requestLock(){ document.body.requestPointerLock({unadjustedMovement:true}); }
document.getElementById('start').onclick=(e)=>{ e.preventDefault(); overlay.style.display='none'; requestLock(); };
document.addEventListener('click', ()=>{ if(document.pointerLockElement!==document.body) requestLock(); });
let yaw=0, pitch=0, wasLocked=false;
function onMouse(e){ const s=0.0022; yaw -= e.movementX*s; pitch -= e.movementY*s; pitch=clamp(pitch,-Math.PI/2,Math.PI/2); player.rotation.y=yaw; camera.rotation.x=pitch; }
document.addEventListener('pointerlockchange', ()=>{
  const locked=(document.pointerLockElement===document.body);
  if(locked){ wasLocked=true; setHint(false); document.addEventListener('mousemove', onMouse); }
  else { document.removeEventListener('mousemove', onMouse); setHint(true); }
});
document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && wasLocked && document.pointerLockElement!==document.body) setHint(true); });
window.addEventListener('blur', ()=>{ if(document.pointerLockElement===document.body) setHint(true); });

// ===== Player movement =====
const player=new THREE.Object3D(); player.position.set(0,40,0); player.add(camera); scene.add(player);
const keys={w:false,a:false,s:false,d:false,space:false,shift:false,fly:false};
addEventListener('keydown', e=>{ if(e.code==='KeyW')keys.w=true; if(e.code==='KeyA')keys.a=true; if(e.code==='KeyS')keys.s=true; if(e.code==='KeyD')keys.d=true; if(e.code==='Space')keys.space=true; if(e.code==='ShiftLeft')keys.shift=true; if(e.code==='KeyF')keys.fly=!keys.fly; if(e.code==='F5') saveWorld(); });
addEventListener('keyup', e=>{ if(e.code==='KeyW')keys.w=false; if(e.code==='KeyA')keys.a=false; if(e.code==='KeyS')keys.s=false; if(e.code==='KeyD')keys.d=false; if(e.code==='Space')keys.space=false; if(e.code==='ShiftLeft')keys.shift=false; });

let vY=0; const GRAV=25, JUMP=9; let onGround=false;
function updateMove(dt){
  const speed = (keys.shift?10:6);
  const f=new THREE.Vector3(0,0,-1).applyQuaternion(player.quaternion); f.y=0; f.normalize();
  const r=new THREE.Vector3(1,0,0).applyQuaternion(player.quaternion); r.y=0; r.normalize();
  if(keys.w) player.position.addScaledVector(f, speed*dt);
  if(keys.s) player.position.addScaledVector(f,-speed*dt);
  if(keys.a) player.position.addScaledVector(r,-speed*dt);
  if(keys.d) player.position.addScaledVector(r, speed*dt);
  if(keys.fly){ if(keys.space) player.position.y += speed*dt; }
  else{ if(onGround && keys.space){ vY=JUMP; onGround=false; } vY -= GRAV*dt; player.position.y += vY*dt; if(player.position.y<2){ player.position.y=2; vY=0; onGround=true; } }
}

// ===== Voxels with streaming =====
const world=new Map(), meshes=new Map();
function key(cx,cz){ return `${cx},${cz}`; }
function i3(x,y,z){ return (y*CHUNK + z)*CHUNK + x; }
const mats={};
function mat(id){
  if(mats[id]) return mats[id];
  const transparent = id in TRANSPARENT && !PERF_MODE;
  mats[id] = new THREE.MeshLambertMaterial({ color: COLORS[id]||0xffffff, transparent, opacity: transparent? (1-TRANSPARENT[id]) : 1, depthWrite: !transparent });
  return mats[id];
}
function genChunk(cx,cz){
  const arr=new Uint8Array(CHUNK*HEIGHT*CHUNK);
  for(let x=0;x<CHUNK;x++)for(let z=0;z<CHUNK;z++){
    const wx=cx*CHUNK+x, wz=cz*CHUNK+z;
    const h=Math.floor(22 + 12*noise(wx*0.06, wz*0.06) + 3*noise2(wx*0.12, wz*0.12));
    for(let y=0;y<HEIGHT;y++){
      if(y>Math.max(h,SEA)) { arr[i3(x,y,z)]=0; continue; }
      if(y===h){ arr[i3(x,y,z)] = h<=SEA+1 ? BLOCK.Sand : BLOCK.Grass; }
      else if(y>h-3){ arr[i3(x,y,z)] = BLOCK.Dirt; }
      else {
        const r=Math.random();
        if(y<18 && r<0.03) arr[i3(x,y,z)]=BLOCK.Iron;
        else if(y<30 && r<0.06) arr[i3(x,y,z)]=BLOCK.Coal;
        else arr[i3(x,y,z)]=BLOCK.Stone;
      }
      if(!PERF_MODE && y<=SEA && y>h){ arr[i3(x,y,z)]=BLOCK.Water; }
    }
    if(h>SEA+1 && Math.random()<0.05){ plantTree(arr, x, h+1, z); }
  }
  world.set(key(cx,cz),arr);
}
function plantTree(arr,x,y,z){
  const trunk=3+Math.floor(Math.random()*3);
  for(let i=0;i<trunk;i++) setLocal(arr,x,y+i,z,BLOCK.Wood);
  const top=y+trunk;
  for(let dx=-2;dx<=2;dx++)for(let dz=-2;dz<=2;dz++)for(let dy=0;dy<=2;dy++){
    const d=Math.abs(dx)+Math.abs(dz)+dy; if(d<=4) setLocal(arr,x+dx,top+dy,z+dz,BLOCK.Leaves);
  }
}
function setLocal(arr,x,y,z,id){ if(x<0||x>=CHUNK||z<0||z>=CHUNK||y<0||y>=HEIGHT) return; arr[i3(x,y,z)]=id; }
function rebuild(cx,cz){
  const arr=world.get(key(cx,cz)); if(!arr) return;
  const old=meshes.get(key(cx,cz)); if(old){ scene.remove(old.group); old.group.traverse(o=>{ if(o.isMesh||o.isInstancedMesh) o.geometry.dispose(); }); meshes.delete(key(cx,cz)); }
  const group=new THREE.Group(), inst={}; const geom=new THREE.BoxGeometry(1,1,1); const tmp=new THREE.Object3D();
  function get(x,y,z){
    if(y<0||y>=HEIGHT) return BLOCK.Air;
    if(x<0){ const w=world.get(key(cx-1,cz)); return w? w[i3(x+CHUNK,y,z)] : BLOCK.Air; }
    if(x>=CHUNK){ const w=world.get(key(cx+1,cz)); return w? w[i3(x-CHUNK,y,z)] : BLOCK.Air; }
    if(z<0){ const w=world.get(key(cx,cz-1)); return w? w[i3(x,y,z+CHUNK)] : BLOCK.Air; }
    if(z>=CHUNK){ const w=world.get(key(cx,cz+1)); return w? w[i3(x,y,z-CHUNK)] : BLOCK.Air; }
    return arr[i3(x,y,z)];
  }
  for(let x=0;x<CHUNK;x++)for(let z=0;z<CHUNK;z++)for(let y=0;y<HEIGHT;y++){
    const id=arr[i3(x,y,z)]; if(id===BLOCK.Air) continue;
    if(get(x+1,y,z)&&get(x-1,y,z)&&get(x,y+1,z)&&get(x,y-1,z)&&get(x,y,z+1)&&get(x,y,z-1)) continue;
    if(!inst[id]) inst[id]=new THREE.InstancedMesh(geom, mat(id), 1), inst[id].count=0;
    tmp.position.set(cx*CHUNK+x, y, cz*CHUNK+z); tmp.updateMatrix(); inst[id].setMatrixAt(inst[id].count++, tmp.matrix);
  }
  for(const id in inst){ inst[id].instanceMatrix.needsUpdate=true; group.add(inst[id]); }
  scene.add(group); meshes.set(key(cx,cz), {group, inst});
}
let curCX=0, curCZ=0; // for streaming
function rebuildAround(force=false){
  const pcx=Math.floor(player.position.x/CHUNK), pcz=Math.floor(player.position.z/CHUNK);
  if(!force && pcx===curCX && pcz===curCZ) return;
  curCX=pcx; curCZ=pcz;
  const needed=new Set();
  for(let dx=-RADIUS; dx<=RADIUS; dx++) for(let dz=-RADIUS; dz<=RADIUS; dz++){
    const k=key(pcx+dx,pcz+dz); needed.add(k); if(!world.has(k)) genChunk(pcx+dx,pcz+dz); rebuild(pcx+dx,pcz+dz);
  }
  // unload far chunks
  for(const k of Array.from(meshes.keys())){ if(!needed.has(k)){ const m=meshes.get(k); scene.remove(m.group); m.group.traverse(o=>{ if(o.isMesh||o.isInstancedMesh) o.geometry.dispose(); }); meshes.delete(k); } }
}
rebuildAround(true);

// ===== Ray pick =====
const ray=new THREE.Raycaster();
function setBlock(ix,iy,iz,id){
  const cx=Math.floor(ix/CHUNK), cz=Math.floor(iz/CHUNK);
  const wx=ix-cx*CHUNK, wz=iz-cz*CHUNK; const arr=world.get(key(cx,cz)); if(!arr) return;
  if(iy<0||iy>=HEIGHT||wx<0||wx>=CHUNK||wz<0||wz>=CHUNK) return;
  arr[i3(wx,iy,wz)]=id; rebuild(cx,cz);
  if(wx===0) rebuild(cx-1,cz); if(wx===CHUNK-1) rebuild(cx+1,cz); if(wz===0) rebuild(cx,cz-1); if(wz===CHUNK-1) rebuild(cx,cz+1);
}
function pick(place){
  ray.setFromCamera(new THREE.Vector2(0,0), camera);
  const step=0.1, max=6;
  for(let t=0;t<max;t+=step){
    const p=ray.ray.at(t, new THREE.Vector3());
    const ix=Math.floor(p.x), iy=Math.floor(p.y), iz=Math.floor(p.z);
    const cx=Math.floor(ix/CHUNK), cz=Math.floor(iz/CHUNK); const arr=world.get(key(cx,cz)); if(!arr) continue;
    const wx=ix-cx*CHUNK, wz=iz-cz*CHUNK; if(iy<0||iy>=HEIGHT||wx<0||wx>=CHUNK||wz<0||wz>=CHUNK) continue;
    const id=arr[i3(wx,iy,wz)];
    if(id!==BLOCK.Air){
      if(place){ const prev=ray.ray.at(Math.max(0,t-step*1.5), new THREE.Vector3()); setBlock(Math.floor(prev.x),Math.floor(prev.y),Math.floor(prev.z), BLOCK_LIST[selected]); }
      else setBlock(ix,iy,iz, BLOCK.Air);
      return true;
    }
  }
  if(place){ const p=ray.ray.at(3, new THREE.Vector3()); setBlock(Math.floor(p.x),Math.floor(p.y),Math.floor(p.z), BLOCK_LIST[selected]); return true; }
  return false;
}
addEventListener('mousedown', e=>{ if(document.pointerLockElement!==document.body) return; if(e.button===0) pick(false); if(e.button===2){ e.preventDefault(); pick(true); } });
addEventListener('contextmenu', e=> e.preventDefault());

// ===== Save / Load =====
function saveWorld(){
  const obj={chunks:{}}; for(const [k,arr] of world.entries()) obj.chunks[k]=Array.from(arr);
  localStorage.setItem('minicraft_perf_save', JSON.stringify(obj));
  console.log('World saved');
}
function loadWorld(){
  const s=localStorage.getItem('minicraft_perf_save'); if(!s) return false;
  try{ const obj=JSON.parse(s); for(const k in obj.chunks) world.set(k, new Uint8Array(obj.chunks[k])); rebuildAround(true); return true; }catch(e){ console.warn('load fail',e); return false; }
} loadWorld();

// ===== Loop (with FPS cap & streaming) =====
let last=performance.now(), t=0, acc=0, minFrame=1000/60; // cap 60fps
function loop(now){
  const dt=(now-last); last=now; acc+=dt; if(acc<minFrame){ requestAnimationFrame(loop); return; }
  const sdt=Math.min(0.033, acc/1000); acc=0;

  if(!PERF_MODE){ t+=sdt; const day=(Math.sin(t*0.05)+1)/2; sun.intensity=0.4+0.6*day; scene.background.setHSL(0.58,0.45,0.5+0.2*day); }

  updateMove(sdt);
  rebuildAround(false);

  renderer.render(scene, camera);
  frames++;
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
